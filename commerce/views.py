from django.shortcuts import render,redirect,get_object_or_404
from django.db import transaction
from django.urls import reverse
import json
from django.http import HttpResponse
from django.template.loader import render_to_string
from django.contrib.auth.decorators import login_required
from users.decorators import block_check
from django.contrib import messages
from .models import Cart,CartItem,OrderItem,Orders,Wishlist,WishlistItem
from users.models import User,UserAddress
from product.models import Category,Product,ProductVariant
from .utils.trigger import trigger
from decimal import Decimal

@block_check
@login_required
def load_wishlist_items(request):
    """Loads the list of wishlist item cards (the partial) via HTMX."""
    wishlist, _ = Wishlist.objects.get_or_create(user=request.user)
    
    # Efficiently fetch WishlistItem objects, selecting the related ProductVariant
    wishlist_items = WishlistItem.objects.filter(wishlist=wishlist).select_related('product')
    
    # Pass the actual ProductVariant objects to the template loop
    products = [item.product for item in wishlist_items]
    
    return render(request, "commerce/wishlist/wishlist_items.html", {"products": products})

@block_check
@login_required
def wishlist(request):
    """Loads the main wishlist page (the parent container)."""
    return render(request, "commerce/wishlist/wishlist.html", {})


@block_check
@login_required
def toggle_wishlist(request, p_id):
    wishlist, _ = Wishlist.objects.get_or_create(user=request.user)
    variant = get_object_or_404(ProductVariant, id=p_id)
    
    item_qs = WishlistItem.objects.filter(wishlist=wishlist, product=variant)
    
    if item_qs.exists():
        # --- ACTION: REMOVE ---
        item_qs.delete()
        
        # 1. Set the new icon (Hollow heart)
        icon_html = '<i class="far fa-heart"></i>' # Or 'far fa-heart' depending on your icon set
        
        # 2. Set Message and Type (INFO for removal)
        message = f"{variant.product.name} removed from wishlist."
        toast_type = "warning" # This will likely be Blue or Gray depending on your JS mapping
        
    else:
        # --- ACTION: ADD ---
        WishlistItem.objects.create(wishlist=wishlist, product=variant)
        
        # 1. Set the new icon (Solid Red heart)
        icon_html = '<i class="fas fa-heart text-red-500"></i>'
        
        # 2. Set Message and Type (SUCCESS for addition)
        message = f"{variant.product.name} added to wishlist!"
        toast_type = "success" # Green

    # Return the HTML for the icon to update the button
    response = HttpResponse(icon_html, status=200)

    # Build the header with the DYNAMIC toast type
    header_data = {
        "toast": {
            "message": message,
            "type": toast_type  # <--- FIXED: Now dynamic
        },
        "wishlistUpdated": True 
    }
    response["HX-Trigger"] = json.dumps(header_data)
    
    return response


@block_check
@login_required
@transaction.atomic # CRITICAL: Ensures atomic add-to-cart and delete-from-wishlist
def move_to_cart(request, p_id):
    """Moves an item from the wishlist to the cart."""
    variant = get_object_or_404(ProductVariant, id=p_id)
    wishlist, _ = Wishlist.objects.get_or_create(user=request.user)

    # 1. Use the existing logic to add/update the item in the cart
    # This automatically handles stock/quantity checks and returns a trigger response.
    cart_response = add_to_cart_logic(request, variant.product, variant)
    
    # 2. Check if the cart operation was successful (status 204 means success with no content swap)
    if cart_response.status_code == 204:
        # Cart addition succeeded: Delete from wishlist
        wishlist_item_qs = WishlistItem.objects.filter(wishlist=wishlist, product=variant)
        wishlist_item_qs.delete()
        
        # 3. Augment the HTMX header from add_to_cart_logic
        header_data = json.loads(cart_response["HX-Trigger"])
        
        # Add the new global trigger for the wishlist container/badge
        header_data["wishlistUpdated"] = True
        cart_response["HX-Trigger"] = json.dumps(header_data)
        
        # The 204 status code already tells HTMX to remove the card (hx-swap="outerHTML")
        return cart_response
        
    else:
        # Cart addition failed (e.g., out of stock). Return the error response 
        # generated by add_to_cart_logic, and DO NOT delete from the wishlist.
        return cart_response
    
    # commerce/views.py (Add this function)

@block_check
@login_required
def wishlist_count(request):
    """Returns the current count of wishlist items for the navbar badge."""
    if not request.user.is_authenticated:
        return HttpResponse("0")

    # 1. Get the user's Wishlist
    wishlist, created = Wishlist.objects.get_or_create(user=request.user)
    
    # 2. Count the number of associated WishlistItem objects (using the related name)
    # Assuming 'wishlist_items' is the related_name on the Wishlist model
    count = wishlist.wishlist_items.count() 

    # 3. Return the count as a plain HttpResponse
    return HttpResponse(count)


@block_check
@login_required
def add_cart_product(request, product_id):
    product = get_object_or_404(Product, id=product_id, is_active=True, is_deleted=False)
    variant = product.variants.filter(is_deleted=False).first()
    return add_to_cart_logic(request, product, variant)

@block_check
@login_required
def add_cart_variant(request, variant_id):

    variant = get_object_or_404(ProductVariant, id=variant_id, is_deleted=False)
    product = variant.product

    return add_to_cart_logic(request, product, variant)

@block_check
@login_required
def add_to_cart_logic(request, product, variant):
    quantity = 1

    if variant.stock < 1:
        return trigger("Product is out of stock.", "error")

    cart, _ = Cart.objects.get_or_create(user=request.user)
    item = CartItem.objects.filter(cart=cart, variant=variant).first()

    if item:
        if item.quantity + quantity > variant.stock:
            return trigger("Only limited stock available.", "error")
        if item.quantity + quantity > 5:
           return trigger("Cannot add more than 5 per order.", "error")
        
        item.quantity += quantity
        item.save()
        return trigger("Quantity updated in cart!", "success", update=True)

    CartItem.objects.create(cart=cart, product=product, variant=variant, quantity=quantity)
    return trigger("Product added to cart!", "success", update=True)

@block_check
@login_required    
def cart_page(request):

    cart, _ = Cart.objects.get_or_create(user=request.user)
    cart_items = cart.items.select_related("product", "variant").all()

    validation_required = False
    
    for item in list(cart_items): 
        
        if item.variant.stock == 0:
            item.delete()
            messages.error(request, f"âš ï¸ **'{item.product.name}'** is now out of stock and was removed from your cart.")
            validation_required = True
            
        elif item.quantity > item.variant.stock:
            old_quantity = item.quantity
            item.quantity = item.variant.stock
            item.save()
            messages.warning(request, 
                f"ðŸš¨ **Quantity reduced** for '{item.product.name}'. Max available stock is now {item.variant.stock} (was {old_quantity})."
            )
            validation_required = True
            
    
    if validation_required:
        return redirect('cart_page')
    return render(request, "commerce/cart/cart_page.html", {
        "cart": cart,
        "cart_items": cart_items,
    })

# for product details page
@block_check
@login_required
def stock_status_for_variant(request, variant_id):
    
    variant = get_object_or_404(ProductVariant, id=variant_id, is_deleted=False)
    cart, _ = Cart.objects.get_or_create(user=request.user)
    cart_item = cart.items.filter(variant=variant).first()
    
    in_cart_qty = cart_item.quantity if cart_item else 0

    max_addable_qty = 5 
    
    remaining_stock_in_db = variant.stock - in_cart_qty
    remaining_stock_to_add = max_addable_qty - in_cart_qty
    
    available_to_add = max(0, min(remaining_stock_in_db, remaining_stock_to_add))
    
    context = {
        'variant': variant,
        'in_cart_qty': in_cart_qty,
        'available_to_add': available_to_add,
        'total_stock': variant.stock, 
    }   
    return render(request, "commerce/product/_stock_status.html", context)


@block_check
@login_required
def increase_quantity(request, item_id):

    item = get_object_or_404(
        CartItem.objects.select_related("product", "variant", "cart"),
        id=item_id,
        cart__user=request.user
    )

    if item.quantity < item.variant.stock and item.quantity < 5:
        item.quantity += 1
        item.save()
        message="Quantity Increased."
    else:
        message = "Maximum quantity reached (5) or out of stock."
    data = {
        "toast": {"message": message, "type": "info"},
        "update-cart": True 
    }
    response = render(request, "commerce/cart/_cart_item.html", {
        "item": item
    })
    response["HX-Trigger"] = json.dumps(data)
    return response


@block_check
@login_required
def decrease_quantity(request, item_id):
    item = get_object_or_404(
        CartItem.objects.select_related("product", "variant", "cart"),
        id=item_id,
        cart__user=request.user
    )

    if item.quantity > 1:
        item.quantity -= 1
        item.save()
        message="Quantity decreased."
    else:
        message = "Minimum quantity reached."
    data = {
        "toast": {"message": message, "type": "warning"},
        "update-cart": True 
    }
    
    response = render(request, "commerce/cart/_cart_item.html", {
        "item": item
    })
    response["HX-Trigger"] = json.dumps(data)
    return response

 

@block_check
@login_required
def remove_cart_item(request,item_id):
    
    item = get_object_or_404(
        CartItem.objects.select_related("cart"),
        id=item_id,
        cart__user=request.user
    )  
    cart = item.cart if item else None

    if item:
        item.delete()
    if cart.items.count()==0:
        response=HttpResponse("")
        response["HX-Location"]=reverse("cart_page")
        return response
    response = HttpResponse("")    
    response["HX-Trigger"] = "update-cart"
    return response

@block_check
@login_required
def cart_count(request):
    if not request.user.is_authenticated:
        return HttpResponse("0")  

    cart, created = Cart.objects.get_or_create(user=request.user)
    count = cart.items.count()

    return HttpResponse(count)

@block_check
@login_required
def cart_totals(request):
    if not request.user.is_authenticated:
        return HttpResponse("")

    cart, _ = Cart.objects.get_or_create(user=request.user)
    items = cart.items.select_related("variant", "product")
    if items.count() == 0:
        return HttpResponse("")

    subtotal =Decimal(0)

    for i in items:
        if not i.variant or i.variant.sales_price is None:
            continue
        subtotal += Decimal(i.variant.sales_price) * i.quantity

    if subtotal ==Decimal(0):
        shipping_cost=Decimal("0")
    else:
        shipping_cost = Decimal("0") if subtotal >= 1000 else Decimal("80")

    discount = Decimal("0")
    total = subtotal + shipping_cost - discount

    context = {
        "subtotal": subtotal,
        "shipping_cost": shipping_cost,
        "discount": discount,
        "total": total,
    }

    return render(request, "commerce/cart/_cart_totals.html", context)

@login_required
def checkout(request):
    user=request.user
    cart,_=Cart.objects.get_or_create(user=user)
    
    products=cart.items.select_related("variant",'product').all()
    if not products.exists():
        messages.error(request,"Your cart is empty!")
        return redirect('cart_page')
    
    addresses=user.addresses.filter(is_deleted=False)

    subtotal=sum((i.variant.sales_price * i.quantity) for i in products)
    shipping_cost= 0 if subtotal>=1000 else 80
    total = subtotal + shipping_cost
    request.session["checkout_cart_update_at"]=cart.updated_at.timestamp()
    context={
        "products":products,
        "addresses":addresses,
        "subtotal":subtotal,
        "shipping_cost":shipping_cost,
        "total":total
    }
    return render(request,'commerce/checkout/checkout_page.html',context)

@login_required
def place_order(request):
    if request.method!="POST":
        return redirect('checkout')


    user=request.user
    cart,_=Cart.objects.get_or_create(user=user)

    last_checkout_time=request.session.get("checkout_cart_updated_at")

    if last_checkout_time and float(last_checkout_time)!=float(cart.updated_at.timestamp()):
        messages.error(request,"Your cart was updated. Please review checkout again.")
        return request('checkout')
    
    with transaction.atomic():
        items = cart.items.select_related("variant","product").select_for_update()

        if not items.exists():
            messages.error(request,"Your cart is empty!")
            return redirect("cart_page")

        address_id=request.POST.get('address')
        payment_method=request.POST.get('payment_method')

        address=get_object_or_404(UserAddress,id=address_id,user=user)

        for item in items:
            if item.quantity>item.variant.stock:
                messages.error(request,
                f"Only {item.variant.stock} left for {item.variant.material_type}. Please update your cart.")
                return redirect('cart_page')
            
        subtotal= sum(item.variant.sales_price*item.quantity for item in items)
        delivery_charge= 0 if subtotal >=1000 else 80
        total = subtotal+delivery_charge

        order = Orders.objects.create(
            user=user,
            address=address,
            total_price_before_discount=subtotal,
            total_price=total,
            payment_method=payment_method,
            delivery_charge=delivery_charge,
            
        )
        for item in items:
            OrderItem.objects.create(
                order=order,
                product=item.variant,
                quantity=item.quantity,
                unit_price=item.variant.sales_price,
                price=item.variant.sales_price * item.quantity,

            )
            item.variant.stock -=item.quantity
            item.variant.save(update_fields=['stock'])
            messages.success(request, "Your order was placed successfully!")

    items.delete()

    request.session.pop('checkout_cart_updated_at',None)
    return redirect("order_success",order_id=order.order_id)

@login_required
def order_success(request,order_id):
    order=get_object_or_404(
        Orders.objects.select_related("address").prefetch_related("items__product"),
        order_id=order_id,
        user=request.user
    )
    return render(request,"commerce/order/order_success.html",{"order":order})

@login_required
def my_orders(request):
    orders=Orders.objects.filter(user=request.user).order_by("-created_at")
    return render(request,"commerce/order/my_orders.html",{"orders":orders})


@login_required
def user_order_detail(request, order_id):
    order = get_object_or_404(Orders, order_id=order_id, user=request.user)
    items = order.items.select_related("product", "product__product")
    return render(request, "commerce/order/order_details.html", {
        "order": order,
        "items": items,
    })
